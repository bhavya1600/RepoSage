{
  "repository": {
    "name": "local-LLM-with-RAG",
    "description": "Running local Language Language Models (LLM) to perform Retrieval-Augmented Generation (RAG)",
    "language": "Python"
  },
  "projectUnderstanding": "1. **Project Overview**:  \n   An experimental project for running local LLMs (via Ollama) with Retrieval-Augmented Generation (RAG) to answer questions using documents (PDFs/Markdown). Includes a Streamlit-based web UI for interaction.\n\n2. **Main Components**:  \n   - `app.py`: Core script for processing documents, generating embeddings, and answering queries.  \n   - `document_loader.py`: Handles loading and parsing of PDF/Markdown files.  \n   - `llm.py`: Manages interactions with Ollama for LLM inference and embeddings.  \n   - `models.py`: Defines data models and Chroma vector database integration.  \n   - `ui.py`: Streamlit web interface for user interaction.  \n   - `Research/`: Directory containing sample PDF documents for RAG.  \n\n3. **Tech Stack**:  \n   - **Languages**: Python  \n   - **Frameworks/Libraries**:  \n     - [Ollama](https://ollama.ai/) for local LLMs/embeddings  \n     - [LangChain](https://github.com/langchain/langchain) for RAG orchestration  \n     - [Chroma](https://docs.trychroma.com/) for vector storage  \n     - [Streamlit](https://streamlit.io/) for web UI  \n     - [PyPDF](https://pypi.org/project/PyPDF2/) for PDF parsing  \n     - [UV](https://astral.sh/uv) for dependency management  \n\n4. **Architecture**:  \n   Modular monorepo with a pipeline:  \n   `Document Loader` â†’ `Embedding Generation (Ollama)` â†’ `Chroma Vector DB` â†’ `LLM Query (Ollama + LangChain)` â†’ `Streamlit UI`.  \n   Separation of concerns between data processing, model interaction, and user interface.\n\n5. **Key Limitations/Constraints**:  \n   - Embeddings are reloaded on each run (non-persistent storage).  \n   - Experimental focus with minimal production-ready optimizations.  \n   - Relies on Ollama's local model execution, limiting cloud/deployment flexibility.  \n   - No explicit error handling or scalability features.",
  "fileTree": {
    "name": "root",
    "type": "directory",
    "children": {
      "images": {
        "name": "images",
        "type": "directory",
        "children": {
          "streamlit_ui.png": {
            "name": "streamlit_ui.png",
            "type": "blob",
            "children": {}
          },
          "wizard_experimenting.jpg": {
            "name": "wizard_experimenting.jpg",
            "type": "blob",
            "children": {}
          }
        }
      },
      "Research": {
        "name": "Research",
        "type": "directory",
        "children": {
          "2304.03442v1.pdf": {
            "name": "2304.03442v1.pdf",
            "type": "blob",
            "children": {}
          },
          "2305.14325.pdf": {
            "name": "2305.14325.pdf",
            "type": "blob",
            "children": {}
          },
          "2308.10848.pdf": {
            "name": "2308.10848.pdf",
            "type": "blob",
            "children": {}
          },
          "2309.14391.pdf": {
            "name": "2309.14391.pdf",
            "type": "blob",
            "children": {}
          }
        }
      },
      ".gitignore": {
        "name": ".gitignore",
        "type": "blob",
        "children": {}
      },
      "app.py": {
        "name": "app.py",
        "type": "blob",
        "children": {}
      },
      "document_loader.py": {
        "name": "document_loader.py",
        "type": "blob",
        "children": {}
      },
      "LICENSE": {
        "name": "LICENSE",
        "type": "blob",
        "children": {}
      },
      "llm.py": {
        "name": "llm.py",
        "type": "blob",
        "children": {}
      },
      "models.py": {
        "name": "models.py",
        "type": "blob",
        "children": {}
      },
      "pyproject.toml": {
        "name": "pyproject.toml",
        "type": "blob",
        "children": {}
      },
      "pyrightconfig.json": {
        "name": "pyrightconfig.json",
        "type": "blob",
        "children": {}
      },
      "readme.md": {
        "name": "readme.md",
        "type": "blob",
        "children": {}
      },
      "ui.py": {
        "name": "ui.py",
        "type": "blob",
        "children": {}
      },
      "uv.lock": {
        "name": "uv.lock",
        "type": "blob",
        "children": {}
      }
    }
  },
  "fileMetadata": [
    {
      "path": "app.py",
      "metadata": {
        "name": "app.py",
        "path": "app.py",
        "imports": [
          "langchain_ollama.ChatOllama",
          "models.check_if_model_is_available",
          "document_loader.load_documents_into_database",
          "argparse",
          "sys",
          "llm.getChatChain"
        ],
        "mainPurpose": "Main script to run a local LLM with RAG using Ollama, load documents, and interact with the user.",
        "type": "script",
        "functions": [
          {
            "name": "main",
            "purpose": "Main function to check model availability, load documents, and interact with the user.",
            "input": "llm_model_name: str, embedding_model_name: str, documents_path: str",
            "output": "None"
          },
          {
            "name": "parse_arguments",
            "purpose": "Parse command line arguments for the script.",
            "input": "None",
            "output": "argparse.Namespace"
          }
        ],
        "exports": [],
        "dependencies": [
          "langchain_ollama",
          "models",
          "document_loader",
          "argparse",
          "sys",
          "llm"
        ],
        "finalReturnType(s)": "None"
      }
    },
    {
      "path": "document_loader.py",
      "metadata": {
        "name": "document_loader.py",
        "path": "document_loader.py",
        "imports": [
          "os",
          "List",
          "Document",
          "DirectoryLoader",
          "PyPDFLoader",
          "TextLoader",
          "OllamaEmbeddings",
          "Chroma",
          "RecursiveCharacterTextSplitter"
        ],
        "mainPurpose": "Load documents from a specified directory into a Chroma database after splitting the text into chunks, and provide functions to handle document loading and embedding.",
        "type": "module",
        "functions": [
          {
            "name": "load_documents_into_database",
            "purpose": "Loads documents from the specified directory into the Chroma database after splitting the text into chunks.",
            "input": "model_name: str, documents_path: str, reload: bool = True",
            "output": "Chroma"
          },
          {
            "name": "load_documents",
            "purpose": "Loads documents from the specified directory path.",
            "input": "path: str",
            "output": "List[Document]"
          }
        ],
        "exports": [
          "load_documents_into_database",
          "load_documents"
        ],
        "dependencies": [
          "langchain_community.document_loaders.DirectoryLoader",
          "langchain_community.document_loaders.PyPDFLoader",
          "langchain_community.document_loaders.TextLoader",
          "langchain_core.documents.Document",
          "langchain_ollama.OllamaEmbeddings",
          "langchain_community.vectorstores.Chroma",
          "langchain.text_splitter.RecursiveCharacterTextSplitter"
        ],
        "finalReturnType(s)": "Chroma, List[Document]"
      }
    },
    {
      "path": "llm.py",
      "metadata": {
        "name": "llm.py",
        "path": "llm.py",
        "imports": [
          "operator.itemgetter",
          "langchain.callbacks.streaming_stdout.StreamingStdOutCallbackHandler",
          "langchain.memory.ConversationBufferMemory",
          "langchain_core.prompts.ChatPromptTemplate",
          "langchain_core.runnables.RunnableLambda",
          "langchain_core.runnables.RunnablePassthrough",
          "langchain_core.messages.get_buffer_string",
          "langchain_core.prompts.format_document",
          "langchain.prompts.prompt.PromptTemplate"
        ],
        "mainPurpose": "This module provides functions to create and manage conversational chains for a research assistant chatbot, leveraging LangChain and a document retriever.",
        "type": "module",
        "functions": [
          {
            "name": "_combine_documents",
            "purpose": "Combines multiple documents into a single string using a specified document prompt and separator.",
            "input": "docs (list of documents), document_prompt (PromptTemplate), document_separator (str)",
            "output": "str"
          },
          {
            "name": "getStreamingChain",
            "purpose": "Creates a streaming chain for processing questions and retrieving relevant documents.",
            "input": "question (str), memory (ConversationBufferMemory), llm (language model), db (document retriever)",
            "output": "Streaming chain"
          },
          {
            "name": "getChatChain",
            "purpose": "Creates a chat chain for processing questions and retrieving relevant documents, with memory management.",
            "input": "llm (language model), db (document retriever)",
            "output": "Function that takes a question (str) and processes it using the chat chain."
          }
        ],
        "exports": [
          "getStreamingChain",
          "getChatChain"
        ],
        "dependencies": [
          "langchain",
          "langchain_core",
          "operator"
        ],
        "finalReturnType(s)": "Streaming chain, Function"
      }
    },
    {
      "path": "models.py",
      "metadata": {
        "name": "models.py",
        "path": "models.py",
        "imports": [
          "ollama",
          "tqdm"
        ],
        "mainPurpose": "Provides functions to manage and interact with Ollama models, including checking model availability, pulling models, and listing available models.",
        "type": "module",
        "functions": [
          {
            "name": "__pull_model",
            "purpose": "Pulls a specified model from the Ollama repository and displays a progress bar for the download.",
            "input": "name: str - The name of the model to pull.",
            "output": "None"
          },
          {
            "name": "__is_model_available_locally",
            "purpose": "Checks if a specified model is available locally by attempting to show its details.",
            "input": "model_name: str - The name of the model to check.",
            "output": "bool - True if the model is available locally, False otherwise."
          },
          {
            "name": "get_list_of_models",
            "purpose": "Retrieves a list of available models from the Ollama repository.",
            "input": "None",
            "output": "list[str] - A list of model names available in the Ollama repository."
          },
          {
            "name": "check_if_model_is_available",
            "purpose": "Ensures that the specified model is available locally. If not, it attempts to pull it from the Ollama repository.",
            "input": "model_name: str - The name of the model to check.",
            "output": "None"
          }
        ],
        "exports": [
          "get_list_of_models",
          "check_if_model_is_available"
        ],
        "dependencies": [
          "ollama",
          "tqdm"
        ],
        "finalReturnType(s)": "None"
      }
    },
    {
      "path": "ui.py",
      "metadata": {
        "name": "ui.py",
        "path": "ui.py",
        "imports": [
          "streamlit",
          "os",
          "langchain_ollama.ChatOllama",
          "document_loader.load_documents_into_database",
          "models.get_list_of_models",
          "llm.getStreamingChain"
        ],
        "mainPurpose": "To create a Streamlit-based UI for interacting with a local LLM using RAG (Retrieval-Augmented Generation) to answer questions based on indexed documents.",
        "type": "Script",
        "functions": [
          {
            "name": "get_list_of_models",
            "purpose": "Retrieve a list of available models.",
            "input": "",
            "output": "List of models"
          },
          {
            "name": "load_documents_into_database",
            "purpose": "Load documents into a database using an embedding model.",
            "input": "Embedding model and folder path",
            "output": "Database instance"
          },
          {
            "name": "getStreamingChain",
            "purpose": "Generate a streaming chain for processing user queries.",
            "input": "User prompt, chat history, LLM instance, and database instance",
            "output": "Streaming chain"
          }
        ],
        "exports": [],
        "dependencies": [
          "streamlit",
          "os",
          "langchain_ollama",
          "document_loader",
          "models",
          "llm"
        ],
        "finalReturnType(s)": "None"
      }
    }
  ],
  "callHierarchy": "```\nðŸš€ app.py (ENTRY POINT)\nâ”£â”â” ðŸ”„ main(llm_model_name: str, embedding_model_name: str, documents_path: str) â†’ None [app.py]\nâ”ƒ   â”£â”â” ðŸ§ª check_if_model_is_available(model_name: str) â†’ None [models.py]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ“¥ __is_model_available_locally(model_name: str) â†’ bool [models.py]\nâ”ƒ   â”ƒ   â”—â”â” ðŸ“¥ __pull_model(name: str) â†’ None [models.py]\nâ”ƒ   â”£â”â” ðŸ“ load_documents_into_database(model_name: str, documents_path: str, reload: bool) â†’ Chroma [document_loader.py]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ“„ load_documents(path: str) â†’ List[Document] [document_loader.py]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ“„ RecursiveCharacterTextSplitter() â†’ TextSplitter [langchain.text_splitter]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ“¦ OllamaEmbeddings(model_name: str) â†’ Embeddings [langchain_ollama]\nâ”ƒ   â”ƒ   â”—â”â” ðŸ—„ï¸ Chroma.from_documents() â†’ VectorDB [langchain_community.vectorstores]\nâ”ƒ   â”£â”â” ðŸ¤– getChatChain(llm: ChatOllama, db: Chroma) â†’ Function [llm.py]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ§  _combine_documents(docs: List, document_prompt: PromptTemplate, separator: str) â†’ str [llm.py]\nâ”ƒ   â”ƒ   â”£â”â” ðŸ§  ChatPromptTemplate.from_messages() â†’ Prompt [langchain_core.prompts]\nâ”ƒ   â”ƒ   â”—â”â” ðŸ§  ConversationBufferMemory() â†’ Memory [langchain.memory]\nâ”ƒ   â”—â”â” ðŸ§‘â€ðŸ’» User interaction loop (query processing) [app.py]\nâ”ƒ       â”—â”â” ðŸ¤– chat_chain.invoke(question: str) â†’ Response [llm.py]\n\nðŸš€ ui.py (ENTRY POINT - Streamlit Web UI)\nâ”£â”â” ðŸ–¥ï¸ Streamlit app initialization [ui.py]\nâ”ƒ   â”£â”â” ðŸ“¦ get_list_of_models() â†’ List[str] [models.py]\nâ”ƒ   â”£â”â” ðŸ“ load_documents_into_database(embedding_model: str, documents_path: str) â†’ Chroma [document_loader.py]\nâ”ƒ   â”—â”â” ðŸ¤– getStreamingChain(question: str, memory: Memory, llm: ChatOllama, db: Chroma) â†’ StreamingChain [llm.py]\nâ”ƒ       â”£â”â” ðŸ§  StreamingStdOutCallbackHandler() â†’ Callback [langchain.callbacks]\nâ”ƒ       â”—â”â” ðŸ§  get_buffer_string() â†’ str [langchain_core.messages]\n\nðŸ“¦ Module Dependencies\nâ”£â”â” app.py âž¡ models.py (model availability checks)\nâ”£â”â” app.py âž¡ document_loader.py (document ingestion)\nâ”£â”â” app.py âž¡ llm.py (chat chain creation)\nâ”£â”â” ui.py âž¡ models.py (model listing)\nâ”£â”â” ui.py âž¡ document_loader.py (document ingestion)\nâ”£â”â” ui.py âž¡ llm.py (streaming chain)\nâ”—â”â” All âž¡ langchain_ollama (LLM/embeddings)\n    â”—â”â” All âž¡ langchain_core (base classes)\n```\n\n### Key Execution Flow Analysis:\n1. **Main CLI Execution Path** (`app.py`):\n   - `main()` â†’ `check_if_model_is_available()` (models.py)\n   - `main()` â†’ `load_documents_into_database()` (document_loader.py)\n   - `main()` â†’ `getChatChain()` (llm.py)\n   - Chat loop â†’ `chat_chain.invoke()` (llm.py)\n\n2. **Web UI Execution Path** (`ui.py`):\n   - Streamlit app â†’ `get_list_of_models()` (models.py)\n   - Document upload â†’ `load_documents_into_database()` (document_loader.py)\n   - Query handling â†’ `getStreamingChain()` (llm.py)\n\n3. **Cross-File Dependencies**:\n   - `document_loader.py` uses `OllamaEmbeddings` and `Chroma` from LangChain\n   - `llm.py` combines `ChatOllama` with `Chroma` retriever for RAG\n   - Both entry points share common dependencies on `models.py` and `document_loader.py`\n\n4. **Critical Function Calls**:\n   - `check_if_model_is_available()` ensures required Ollama models are present\n   - `load_documents_into_database()` handles document parsing, splitting, and vectorization\n   - `getChatChain()`/`getStreamingChain()` create LangChain pipelines for RAG\n\nThis architecture follows a clear separation of concerns:\n- **Data Layer**: `document_loader.py` handles document ingestion and vectorization\n- **Model Layer**: `llm.py` and `models.py` manage LLM interactions\n- **Interface Layer**: `app.py` (CLI) and `ui.py` (Streamlit) provide user-facing entry points\n\nThe application supports both direct CLI usage and a web-based interface while maintaining a consistent RAG pipeline through shared modules.",
  "fileAnalysis": [
    {
      "path": "app.py",
      "analysis": "### 1. Main purpose and responsibilities\nThe `app.py` file serves as the main entry point for a local LLM (Large Language Model) with RAG (Retrieval-Augmented Generation) using Ollama. Its primary responsibilities include:\n1. Parsing command-line arguments to configure the LLM and embedding models, as well as the path to the documents.\n2. Checking the availability of the specified LLM and embedding models, and attempting to pull them if they are not available.\n3. Loading documents into a database using the specified embedding model.\n4. Initializing the LLM and setting up the chat chain for interaction.\n5. Running a continuous loop to accept user questions, process them using the chat chain, and display responses until the user exits.\n\n### 2. Key functions and their purposes\n\n- **`main(llm_model_name: str, embedding_model_name: str, documents_path: str) -> None`**:\n  - **Inputs**:\n    - `llm_model_name` (str): The name of the LLM model to use (e.g., \"mistral\").\n    - `embedding_model_name` (str): The name of the embedding model to use (e.g., \"nomic-embed-text\").\n    - `documents_path` (str): The path to the directory containing documents to load (e.g., \"Research\").\n  - **Processing**:\n    1. Checks if the specified LLM and embedding models are available; if not, attempts to pull them.\n    2. Loads documents from `documents_path` into a database using the specified embedding model.\n    3. Initializes the LLM and sets up the chat chain.\n    4. Enters a loop to accept user questions, processes them using the chat chain, and prints responses until the user types \"exit\" or interrupts with `Ctrl+C`.\n  - **Output**: None (runs interactively until terminated).\n\n- **`parse_arguments() -> argparse.Namespace`**:\n  - **Inputs**: None (reads command-line arguments).\n  - **Processing**:\n    1. Defines command-line arguments for the LLM model (`--model`), embedding model (`--embedding_model`), and document path (`--path`).\n    2. Parses the command-line arguments and returns them as a `Namespace` object.\n  - **Output**: `argparse.Namespace` containing the parsed arguments.\n\n### 3. Important interactions with other parts of the system\n- **`models.py`**: Uses `check_if_model_is_available` to verify the availability of the specified LLM and embedding models.\n- **`document_loader.py`**: Uses `load_documents_into_database` to load documents from `documents_path` into a database using the specified embedding model.\n- **`llm.py`**: Uses `getChatChain` to set up the chat chain with the initialized LLM and the document database.\n- **`langchain_ollama`**: Uses `ChatOllama` to initialize the LLM with the specified model name.\n\n### 4. Notable features or patterns\n- **Command-line Interface**: Uses `argparse` to allow users to specify the LLM model, embedding model, and document path at runtime.\n- **Model Availability Check**: Ensures that the required models are available before proceeding, and attempts to pull them if not.\n- **Interactive Loop**: Provides an interactive command-line interface for users to ask questions and receive responses until they choose to exit.\n- **Modular Design**: Relies on separate modules (`models.py`, `document_loader.py`, `llm.py`) for specific functionalities, promoting separation of concerns.\n\n### Overall\n`app.py` is the central script that orchestrates the interaction between the user, the LLM, and the document database. It leverages other modules to handle model availability, document loading, and chat chain setup, providing a streamlined command-line interface for users to interact with the system. The script is designed to be flexible, allowing users to specify different models and document paths, and to be robust by handling potential errors such as missing models or documents."
    },
    {
      "path": "document_loader.py",
      "analysis": "### 1. Main purpose and responsibilities\nThe `document_loader.py` file is responsible for loading documents from a specified directory, splitting them into smaller chunks, and then embedding these chunks into a vector database (Chroma) using the Ollama embeddings model. It also provides functionality to reload documents if needed.\n\n### 2. Key functions and their purposes\n\n- **`load_documents_into_database(model_name: str, documents_path: str, reload: bool = True) -> Chroma`**:\n  - **Inputs**:\n    - `model_name` (str): The name of the Ollama embeddings model to use.\n    - `documents_path` (str): The path to the directory containing the documents to load.\n    - `reload` (bool, optional): Whether to reload the documents or use the existing database. Defaults to True.\n  - **Processing**:\n    - If `reload` is True, it loads the documents from `documents_path` using `load_documents`, splits them into chunks using `TEXT_SPLITTER`, and then embeds them into the Chroma database using the specified Ollama embeddings model.\n    - If `reload` is False, it loads the existing Chroma database from the `PERSIST_DIRECTORY`.\n  - **Output**:\n    - Returns a `Chroma` database instance with the loaded documents.\n\n- **`load_documents(path: str) -> List[Document]`**:\n  - **Inputs**:\n    - `path` (str): The path to the directory containing documents to load.\n  - **Processing**:\n    - Checks if the path exists and raises a `FileNotFoundError` if it does not.\n    - Uses `DirectoryLoader` with `PyPDFLoader` to load PDF files and `TextLoader` to load Markdown files.\n    - Extends the list of documents with the loaded files.\n  - **Output**:\n    - Returns a list of `Document` objects loaded from the specified directory.\n\n### 3. Important interactions with other parts of the system\n- The file interacts with `langchain_community.document_loaders` to load documents of different types (PDF, Markdown).\n- It uses `langchain_ollama` for embeddings and `langchain_community.vectorstores` for storing embeddings in the Chroma database.\n- The `TEXT_SPLITTER` is an instance of `RecursiveCharacterTextSplitter` from `langchain.text_splitter`, used to split documents into smaller chunks.\n\n### 4. Notable features or patterns\n- The code uses a dictionary (`loaders`) to map file extensions to their respective loaders, making it easy to extend support for additional file types.\n- The `load_documents_into_database` function conditionally reloads documents based on the `reload` flag, allowing for flexibility in updating the database.\n- The use of `Chroma.from_documents` and `Chroma` constructors ensures that the database is either created from scratch or loaded from an existing directory, depending on the `reload` flag.\n\n### Overall\nThe `document_loader.py` file provides a structured way to load, split, and embed documents into a vector database using the Ollama embeddings model. It supports multiple file types and allows for conditional reloading of documents, making it a flexible and reusable component in the system."
    },
    {
      "path": "llm.py",
      "analysis": "### 1. Main purpose and responsibilities\nThe `llm.py` file is responsible for setting up and managing the conversational chain for a research assistant chatbot. It integrates LangChain components to handle memory, question rephrasing, document retrieval, and answer generation. The file provides two main functionalities:\n1. **Streaming Chain**: A chain that streams responses to questions using retrieved documents and chat history.\n2. **Chat Chain**: A chain that handles interactive chat sessions with memory, allowing the chatbot to maintain context across multiple turns.\n\n### 2. Key functions and their purposes\n\n#### `_combine_documents(docs, document_prompt=DEFAULT_DOCUMENT_PROMPT, document_separator=\"\\n\\n\")`:\n- **Inputs**:\n  - `docs` (List[Document]): A list of documents to combine.\n  - `document_prompt` (PromptTemplate): A template to format each document (default is `DEFAULT_DOCUMENT_PROMPT`).\n  - `document_separator` (str): A separator to join the formatted documents (default is `\"\\n\\n\"`).\n- **Processing**: Formats each document using `document_prompt` and joins them with `document_separator`.\n- **Output**: A single string containing all formatted documents.\n\n#### `getStreamingChain(question: str, memory, llm, db)`:\n- **Inputs**:\n  - `question` (str): The user's question.\n  - `memory`: The chat history memory (not used in the function, but passed for consistency).\n  - `llm`: The language model to use for generating answers.\n  - `db`: The document database to retrieve relevant documents.\n- **Processing**:\n  1. Sets up a retriever from `db` with `k=10`.\n  2. Constructs a chain that:\n     - Loads chat history from `memory` (but `memory` is not actually used here).\n     - Rephrases the question using `CONDENSE_QUESTION_PROMPT` and `llm`.\n     - Retrieves documents based on the rephrased question.\n     - Combines the documents and generates an answer using `ANSWER_PROMPT` and `llm`.\n- **Output**: A streaming generator for the answer.\n\n#### `getChatChain(llm, db)`:\n- **Inputs**:\n  - `llm`: The language model to use for generating answers.\n  - `db`: The document database to retrieve relevant documents.\n- **Processing**:\n  1. Sets up a retriever from `db` with `k=10`.\n  2. Constructs a chain that:\n     - Loads chat history from `memory` (global `ConversationBufferMemory`).\n     - Rephrases the question using `CONDENSE_QUESTION_PROMPT` and `llm`.\n     - Retrieves documents based on the rephrased question.\n     - Combines the documents and generates an answer using `ANSWER_PROMPT` and `llm`.\n     - Saves the question and answer to `memory`.\n  3. Returns a `chat(question: str)` function that invokes the chain and updates memory.\n- **Output**: A `chat(question: str)` function that can be called to get responses and update memory.\n\n### 3. Important interactions with other parts of the system\n- **LangChain**: The file heavily relies on LangChain components (`ConversationBufferMemory`, `ChatPromptTemplate`, `RunnableLambda`, etc.) to build the conversational chain.\n- **Document Database (`db`)**: The `db` parameter is expected to be a LangChain retriever-compatible object (e.g., a vector store) that provides relevant documents for a given query.\n- **Language Model (`llm`)**: The `llm` parameter is expected to be a LangChain-compatible language model (e.g., OpenAI, HuggingFace) used for generating answers and rephrasing questions.\n\n### 4. Notable features or patterns\n- **Memory Management**: Uses `ConversationBufferMemory` to maintain chat history across turns, but note that `getStreamingChain` does not actually use the passed `memory` (it is hardcoded to use `memory` from the global scope in `getChatChain`).\n- **Modular Chain Construction**: The conversational chain is built using LangChain's `RunnablePassthrough` and `RunnableLambda` to create a pipeline of operations (rephrasing, retrieval, answer generation).\n- **Streaming Support**: `getStreamingChain` returns a streaming generator, allowing for real-time output of the answer.\n- **Prompt Engineering**: Uses carefully designed prompts (`CONDENSE_QUESTION_PROMPT`, `ANSWER_PROMPT`) to guide the language model's behavior.\n\n### Overall\nThe `llm.py` file provides the core functionality for a research assistant chatbot by integrating LangChain components to handle memory, document retrieval, and answer generation. It supports both streaming responses and interactive chat sessions with memory. The code is modular and relies on LangChain's abstractions to build the conversational pipeline. However, there is a discrepancy in how `memory` is handled between `getStreamingChain` and `getChatChain`, which should be addressed for consistency."
    },
    {
      "path": "models.py",
      "analysis": "### 1. Main purpose and responsibilities\nThe `models.py` file is responsible for managing interactions with the Ollama service to check the availability of machine learning models, pull them if they are not available locally, and list available models. It ensures that the required models are present and can be used by other parts of the system.\n\n### 2. Key functions and their purposes\n\n- **`__pull_model(name: str) -> None`**:\n  - **Inputs**: \n    - `name` (str): The name of the model to pull from the Ollama repository.\n  - **Processing**: \n    - Initiates a pull request to the Ollama service for the specified model.\n    - Streams the download progress, updating a progress bar for each digest (part of the model).\n    - Closes the progress bar when a new digest is encountered or when the download is complete.\n  - **Output**: None. The function is responsible for downloading the model and updating the progress bars.\n\n- **`__is_model_available_locally(model_name: str) -> bool`**:\n  - **Inputs**: \n    - `model_name` (str): The name of the model to check for local availability.\n  - **Processing**: \n    - Attempts to retrieve information about the model using `ollama.show(model_name)`.\n    - Returns `True` if the model is found locally, `False` if an error occurs (indicating the model is not available).\n  - **Output**: A boolean indicating whether the model is available locally.\n\n- **`get_list_of_models() -> list[str]`**:\n  - **Inputs**: None.\n  - **Processing**: \n    - Calls `ollama.list()` to get a list of all available models in the Ollama repository.\n    - Extracts the model names from the response and returns them as a list of strings.\n  - **Output**: A list of strings representing the names of available models.\n\n- **`check_if_model_is_available(model_name: str) -> None`**:\n  - **Inputs**: \n    - `model_name` (str): The name of the model to check and potentially pull.\n  - **Processing**: \n    - Checks if the model is available locally using `__is_model_available_locally`.\n    - If not available, attempts to pull the model using `__pull_model`.\n    - Raises exceptions if there are issues communicating with the Ollama service or if the model cannot be found.\n  - **Output**: None. The function ensures the model is available locally or raises an exception.\n\n### 3. Important interactions with other parts of the system\n- The file interacts with the `ollama` library to manage models (pull, list, show).\n- It uses `tqdm` to display progress bars during model downloads.\n- The functions in this file are likely used by other parts of the system (e.g., `llm.py` or `app.py`) to ensure models are available before attempting to use them.\n\n### 4. Notable features or patterns\n- **Lazy Loading**: Models are only pulled when they are not available locally, reducing unnecessary downloads.\n- **Progress Tracking**: Uses `tqdm` to provide visual feedback on the download progress of models.\n- **Error Handling**: Raises specific exceptions when there are issues with the Ollama service or model availability.\n- **Encapsulation**: Private functions (`__pull_model`, `__is_model_available_locally`) are used to hide implementation details from the rest of the system.\n\n### Overall\nThe `models.py` file provides essential functionality for managing machine learning models in the Ollama repository. It ensures that models are available locally, handles downloading them if necessary, and provides a list of available models. The file is designed to be modular and reusable, with clear separation of concerns and robust error handling."
    },
    {
      "path": "ui.py",
      "analysis": "### 1. Main purpose and responsibilities\nThe `ui.py` file is responsible for creating a Streamlit-based user interface for a local Large Language Model (LLM) with Retrieval-Augmented Generation (RAG) capabilities. It allows users to:\n1. Select a model from a list of available models.\n2. Specify a folder path containing documents to be indexed.\n3. Index the documents into a Chroma database using embeddings.\n4. Interact with the LLM by asking questions, leveraging the indexed documents for context.\n\n### 2. Key functions and their purposes\nThe code does not define any functions but uses Streamlit's interactive components to build the UI and manage the application's state. The key interactions are:\n1. **Model Selection**:\n   - Uses `st.sidebar.selectbox` to let the user choose a model from `st.session_state[\"list_of_models\"]`.\n   - If the selected model changes, it updates `st.session_state[\"ollama_model\"]` and `st.session_state[\"llm\"]` with a new `ChatOllama` instance.\n\n2. **Folder Path Input**:\n   - Uses `st.sidebar.text_input` to accept a folder path (`PATH` defaults to \"Research\").\n   - Validates the path and displays an error if invalid.\n\n3. **Indexing Documents**:\n   - When the \"Index Documents\" button is clicked, it calls `load_documents_into_database` to create embeddings and load documents into Chroma.\n   - The resulting database is stored in `st.session_state.db`.\n\n4. **Chat Interface**:\n   - Displays previous chat messages from `st.session_state.messages`.\n   - Uses `st.chat_input` to accept user questions.\n   - If `st.session_state.db` is not `None`, it calls `getStreamingChain` to generate a response, which is streamed to the UI and appended to `st.session_state.messages`.\n\n### 3. Important interactions with other parts of the system\n- **`document_loader.py`**: The `load_documents_into_database` function is imported from here to handle document indexing.\n- **`models.py`**: The `get_list_of_models` function is imported to populate the model selection dropdown.\n- **`llm.py`**: The `getStreamingChain` function is imported to generate responses to user queries using the LLM and the indexed documents.\n- **`langchain_ollama`**: The `ChatOllama` class is used to instantiate the selected LLM.\n\n### 4. Notable features or patterns\n- **Session State Management**: The code uses `st.session_state` to persist the model, database, and chat messages across reruns.\n- **Streaming Responses**: The `getStreamingChain` function streams the LLM's response to the UI in real-time.\n- **Error Handling**: The UI provides warnings and errors for invalid folder paths or unindexed documents.\n- **Modularity**: The UI is separated from the core logic (document loading, model management, and LLM interaction), which is handled by other modules.\n\n### Overall\nThe `ui.py` file provides a user-friendly interface for interacting with a local LLM using RAG. It handles model selection, document indexing, and chat interactions, delegating the core functionality to other modules. The use of Streamlit makes it easy to build and deploy the application, while session state management ensures a smooth user experience."
    }
  ],
  "summary": "### Project Summary\n\nThis project is an experimental implementation of a **local Language Model (LLM) with Retrieval-Augmented Generation (RAG)**. It uses **Ollama** to run LLMs locally and **LangChain** for RAG to answer questions based on user-provided documents (PDFs or Markdown files). The project includes a **Streamlit-based web UI** for interactive use.\n\n---\n\n1. **Main purpose and functionality**:\n   - **Purpose**: Enable users to run LLMs locally and perform RAG to answer questions using their own documents.\n   - **Functionality**:\n     - Load and parse PDF/Markdown documents.\n     - Generate embeddings for document chunks using Ollama.\n     - Store embeddings in a Chroma vector database.\n     - Answer user queries by retrieving relevant documents and generating responses with the LLM.\n     - Provide both a CLI and a Streamlit web UI for interaction.\n\n2. **Tech stack and architecture**:\n   - **Languages**: Python\n   - **Frameworks/Libraries**:\n     - **Ollama**: Local LLM execution and embeddings.\n     - **LangChain**: RAG orchestration.\n     - **Chroma**: Vector storage.\n     - **Streamlit**: Web UI.\n     - **PyPDF**: PDF parsing.\n     - **UV**: Dependency management.\n   - **Architecture**: Modular monorepo with a pipeline:\n     - Document Loader â†’ Embedding Generation (Ollama) â†’ Chroma Vector DB â†’ LLM Query (Ollama + LangChain) â†’ Streamlit UI.\n\n3. **Key components and their interactions**:\n   - **`app.py`**: Main CLI script for checking model availability, loading documents, and running the chat loop.\n   - **`document_loader.py`**: Loads and splits documents, generates embeddings, and stores them in Chroma.\n   - **`llm.py`**: Creates LangChain pipelines for RAG (chat and streaming chains).\n   - **`models.py`**: Manages Ollama models (checking availability, pulling models).\n   - **`ui.py`**: Streamlit web UI for document upload and querying.\n   - **`Research/`**: Sample PDF documents for testing.\n\n4. **Notable features**:\n   - Supports both CLI and web UI.\n   - Uses local LLMs via Ollama, ensuring privacy and offline use.\n   - Modular design allows easy swapping of components (e.g., vector DB, document loaders).\n   - Includes a sample set of research papers for quick testing.\n\n5. **Code organization and structure**:\n   - **Entry Points**: `app.py` (CLI), `ui.py` (Streamlit UI).\n   - **Core Modules**:\n     - `document_loader.py`: Document processing and embedding.\n     - `llm.py`: RAG chain construction.\n     - `models.py`: Ollama model management.\n   - **Dependencies**: Managed via `pyproject.toml` and `uv.lock`.\n   - **Data**: Sample documents in `Research/` directory.\n\n---\n\n**Overall**, this project provides a flexible and locally executable framework for experimenting with RAG using local LLMs, with a focus on modularity and ease of use through both CLI and web interfaces."
}